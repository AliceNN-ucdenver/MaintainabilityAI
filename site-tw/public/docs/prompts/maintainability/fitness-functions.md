# Fitness Functions â€” Maintainability Prompt Pack

> **Fitness Functions** are automated, objective quality gates that continuously validate architectural characteristics. They prevent technical debt by failing builds when code degrades beyond acceptable thresholds.

---

## ðŸŽ¯ What are Fitness Functions?

**Definition**: Executable tests that measure architectural quality metrics (complexity, coverage, performance) and fail if thresholds are exceeded. Think "unit tests for architecture."

**Common Fitness Function Types**:
- **Complexity**: Cyclomatic complexity per function (threshold: â‰¤10)
- **Test Coverage**: Line, branch, and statement coverage (threshold: â‰¥80%)
- **Performance**: p95 latency for critical endpoints (threshold: <200ms)
- **Dependency Freshness**: Age of dependencies (threshold: â‰¤90 days)
- **Security**: High/critical vulnerabilities (threshold: 0)

**Why They Matter**: Without fitness functions, code quality degrades silently over time (architectural erosion). Manual code reviews can't catch every violation.

---

## ðŸ”— Maps to OWASP

**Supports**: All OWASP categories by enforcing quality standards
**Primary**: [A06 - Vulnerable Components](/docs/prompts/owasp/A06_vuln_outdated) (dependency freshness)
**Secondary**: [A04 - Insecure Design](/docs/prompts/owasp/A04_insecure_design) (complexity reduces attack surface)

---

## ðŸ¤– AI Prompt #1: Identify Where to Apply Fitness Functions

<div style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); border-radius: 12px; padding: 24px; margin: 24px 0; border-left: 4px solid #10b981;">

**ðŸ“‹ Copy this prompt and paste it into ChatGPT, Claude, or GitHub Copilot Chat:**

```
Role: You are an Evolutionary Architecture engineer analyzing a codebase to determine which fitness functions would provide the most value.

Context:
I have the following project:

[PASTE YOUR PROJECT DETAILS HERE]

Example:
- Node.js 18 + TypeScript
- 50K+ LOC across 200 files
- Jest test framework
- Express REST API with 30+ endpoints
- PostgreSQL database
- 15 developers contributing
- GitHub Actions CI/CD
- Current issues: high complexity in auth module, inconsistent test coverage, slow dependency updates

Task:
Analyze this project and recommend:

1. Which fitness functions to implement (complexity, coverage, performance, dependencies)
2. Priority order (which will catch the most issues fastest)
3. Baseline thresholds (what limits make sense for THIS codebase, not aspirational goals)
4. Implementation plan (which tools to use, how to integrate with CI)

Format:
For each fitness function, provide:

**Metric**: [What to measure]
**Threshold**: [Acceptable limit based on current state]
**Priority**: [High/Medium/Low]
**Rationale**: [Why this matters for this specific codebase]
**Implementation**: [Which tool/library to use - e.g., ts-complex, autocannon, npm outdated]
**CI Integration**: [How to run in GitHub Actions - be specific]

Focus Areas:
Pay special attention to:
- Hotspot files (high complexity + frequent changes = risk)
- Critical paths (auth, payment, data access)
- Legacy modules (likely candidates for complexity violations)
- Public APIs (need strong test coverage)
- Performance-critical endpoints (user-facing, data-heavy)

Output:
Provide a prioritized list of 3-5 fitness functions with specific thresholds and implementation steps. Start with the fitness function that will catch the most issues with the least effort.
```

</div>

---

## ðŸ¤– AI Prompt #2: Generate Fitness Function Tests

<div style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); border-radius: 12px; padding: 24px; margin: 24px 0; border-left: 4px solid #10b981;">

**ðŸ“‹ Copy this prompt and paste it into Claude Code, GitHub Copilot Chat, or ChatGPT:**

```
Role: You are a software engineer implementing fitness functions as automated tests that run in CI/CD pipelines.

Context:
I have a Node.js 18 + TypeScript project using Jest for testing and GitHub Actions for CI/CD.

Target metrics:
- Cyclomatic complexity â‰¤10 per function
- Test coverage â‰¥80% (line + branch)
- Dependency age â‰¤90 days
- Performance p95 <200ms for /api/* endpoints

Task: Generate 4 executable fitness function test files:

1. tests/fitness-functions/complexity.test.ts
   - Use ts-complex library to analyze TypeScript files
   - Check cyclomatic complexity for all functions in src/
   - Fail if any function exceeds 10
   - Report violations with file:line:function name
   - Suggest refactoring strategies in error message

2. tests/fitness-functions/coverage.test.ts
   - Read coverage/coverage-summary.json (generated by Jest)
   - Check line, branch, function, statement coverage
   - Fail if any metric <80%
   - Compare against baseline/coverage-baseline.json
   - Fail if coverage dropped >2% from baseline

3. tests/fitness-functions/dependency-freshness.test.ts
   - Run "npm outdated --json" to find old packages
   - Check publish date of each dependency using "npm view <pkg>@<version> time.modified"
   - Fail if any dependency >90 days old
   - Warn if dependency >60 days old
   - Categorize by severity: critical (security), major (breaking), minor (safe)

4. tests/fitness-functions/performance.test.ts
   - Start test server programmatically
   - Use autocannon to load test GET /api/users and POST /api/orders
   - Measure p95, p99 latency and throughput
   - Compare against baseline/perf-baseline.json
   - Fail if p95 >200ms or regressed >10% from baseline
   - Clean up server process after test

Requirements:
- All tests must be Jest .test.ts files that can run with "npm test"
- Tests must fail with actionable error messages (include file paths, actual vs expected values)
- Thresholds should be configurable via environment variables (MAX_COMPLEXITY, MIN_COVERAGE, MAX_DEP_AGE_DAYS)
- Include helper functions for calculations (don't repeat code)
- Add JSDoc comments explaining what each function does

Also generate:
- .github/workflows/fitness-functions.yml (runs on every PR, uploads artifacts)
- baseline/coverage-baseline.json (example structure with 85% coverage)
- baseline/perf-baseline.json (example structure with p95: 145ms)
- README-FITNESS-FUNCTIONS.md (explains how to run tests and update baselines)

Output: Complete, executable TypeScript code for all files. Initially configure CI with continue-on-error: true (warning mode) so we can monitor for 2 weeks before switching to blocking mode.
```

</div>

---

## âœ… Human Review Checklist

<div style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); border-radius: 12px; padding: 28px; margin: 28px 0; border-left: 4px solid #10b981;">

<div style="font-size: 20px; font-weight: 700; color: #86efac; margin-bottom: 20px;">After AI generates fitness function tests, review the code carefully before running it:</div>

<div style="display: grid; gap: 20px;">

<div style="background: rgba(16, 185, 129, 0.15); border-left: 4px solid #10b981; border-radius: 8px; padding: 20px;">
  <div style="font-size: 16px; font-weight: 700; color: #86efac; margin-bottom: 12px;">File Structure</div>
  <div style="color: #cbd5e1; font-size: 14px; line-height: 1.8;">
    âœ“ Four test files in fitness-functions directory<br/>
    âœ“ GitHub Actions workflow for CI integration<br/>
    âœ“ Baseline files for tracking historical metrics<br/>
    âœ“ Documentation explaining how to run and update tests
  </div>
</div>

<div style="background: rgba(16, 185, 129, 0.15); border-left: 4px solid #10b981; border-radius: 8px; padding: 20px;">
  <div style="font-size: 16px; font-weight: 700; color: #86efac; margin-bottom: 12px;">Complexity Analysis</div>
  <div style="color: #cbd5e1; font-size: 14px; line-height: 1.8;">
    âœ“ Uses dedicated tool like ts-complex (not manual AST parsing or regex)<br/>
    âœ“ Correctly counts all branching structures (conditionals, loops, case statements, logical operators, exception handlers)<br/>
    âœ“ Error messages pinpoint exact location and suggest specific refactoring patterns<br/>
    âœ“ Threshold configurable through environment variables<br/>
    âœ“ Test by running locally and verifying error messages are actionable
  </div>
</div>

<div style="background: rgba(16, 185, 129, 0.15); border-left: 4px solid #10b981; border-radius: 8px; padding: 20px;">
  <div style="font-size: 16px; font-weight: 700; color: #86efac; margin-bottom: 12px;">Coverage Validation</div>
  <div style="color: #cbd5e1; font-size: 14px; line-height: 1.8;">
    âœ“ Reads Jest's coverage report and validates all four metrics (lines, branches, functions, statements)<br/>
    âœ“ Compares current coverage against stored baseline to detect regressions<br/>
    âœ“ Error messages show which metric failed, by how much, and remediation steps<br/>
    âœ“ Thresholds configurable for starting with realistic values<br/>
    âœ“ Test by generating coverage report first, then running fitness function
  </div>
</div>

<div style="background: rgba(16, 185, 129, 0.15); border-left: 4px solid #10b981; border-radius: 8px; padding: 20px;">
  <div style="font-size: 16px; font-weight: 700; color: #86efac; margin-bottom: 12px;">Dependency Freshness</div>
  <div style="color: #cbd5e1; font-size: 14px; line-height: 1.8;">
    âœ“ Checks actual publish dates of dependencies (not just version numbers)<br/>
    âœ“ Categorizes outdated packages by severity (security vs minor version bumps)<br/>
    âœ“ Provides clear upgrade paths<br/>
    âœ“ Warns before failing to give teams time to plan upgrades<br/>
    âœ“ Integrates with npm audit to flag known security vulnerabilities<br/>
    âœ“ Test by running check and verifying age calculations are accurate
  </div>
</div>

<div style="background: rgba(16, 185, 129, 0.15); border-left: 4px solid #10b981; border-radius: 8px; padding: 20px;">
  <div style="font-size: 16px; font-weight: 700; color: #86efac; margin-bottom: 12px;">Performance Testing</div>
  <div style="color: #cbd5e1; font-size: 14px; line-height: 1.8;">
    âœ“ Starts application programmatically and cleanly shuts down<br/>
    âœ“ Runs realistic load tests against critical endpoints<br/>
    âœ“ Measures both absolute latency (p95, p99) and regression from baseline<br/>
    âœ“ Properly cleans up spawned processes (no background servers left running)<br/>
    âœ“ Error messages show actual vs expected latency with percentage regression<br/>
    âœ“ Test to ensure clean startup, load test, and termination
  </div>
</div>

<div style="background: rgba(16, 185, 129, 0.15); border-left: 4px solid #10b981; border-radius: 8px; padding: 20px;">
  <div style="font-size: 16px; font-weight: 700; color: #86efac; margin-bottom: 12px;">CI/CD Integration</div>
  <div style="color: #cbd5e1; font-size: 14px; line-height: 1.8;">
    âœ“ Workflow runs on every pull request and push to main<br/>
    âœ“ Uses npm ci for deterministic dependency installation<br/>
    âœ“ Initially configured with continue-on-error: true for monitoring period<br/>
    âœ“ Uploads test results as artifacts for historical tracking<br/>
    âœ“ Optionally comments on pull requests with pass/fail summaries<br/>
    âœ“ After monitoring: change to blocking mode with continue-on-error: false
  </div>
</div>

<div style="background: rgba(16, 185, 129, 0.15); border-left: 4px solid #10b981; border-radius: 8px; padding: 20px;">
  <div style="font-size: 16px; font-weight: 700; color: #86efac; margin-bottom: 12px;">Baseline Management</div>
  <div style="color: #cbd5e1; font-size: 14px; line-height: 1.8;">
    âœ“ Baseline files contain realistic starting values based on current codebase<br/>
    âœ“ Files committed to Git with metadata (timestamp, commit SHA)<br/>
    âœ“ Documentation explains how to regenerate baselines<br/>
    âœ“ Update process: validate results, copy fresh metrics, commit with clear message
  </div>
</div>

<div style="background: rgba(16, 185, 129, 0.15); border-left: 4px solid #10b981; border-radius: 8px; padding: 20px;">
  <div style="font-size: 16px; font-weight: 700; color: #86efac; margin-bottom: 12px;">Security Review</div>
  <div style="color: #cbd5e1; font-size: 14px; line-height: 1.8;">
    âœ“ No hardcoded secrets<br/>
    âœ“ No arbitrary code execution patterns (eval, unsanitized exec calls)<br/>
    âœ“ No external network calls that could leak data<br/>
    âœ“ File system operations limited to project directory<br/>
    âœ“ No dependencies from unknown sources<br/>
    âœ“ Tests are self-contained and offline-first<br/>
    âœ“ Red flags: data exfiltration, arbitrary input execution, sensitive system access
  </div>
</div>

<div style="background: rgba(16, 185, 129, 0.15); border-left: 4px solid #10b981; border-radius: 8px; padding: 20px;">
  <div style="font-size: 16px; font-weight: 700; color: #86efac; margin-bottom: 12px;">Final Validation</div>
  <div style="color: #cbd5e1; font-size: 14px; line-height: 1.8;">
    âœ“ Install new dependencies required by tests<br/>
    âœ“ Run each fitness function individually to verify clear output<br/>
    âœ“ Run all tests together to check for conflicts or race conditions<br/>
    âœ“ Validate GitHub Actions workflow syntax before committing<br/>
    âœ“ Optional: test full CI pipeline locally using tools like act<br/>
    âœ“ Expected outcome: tests pass cleanly or fail with actionable error messages
  </div>
</div>

</div>

</div>

---

## ðŸ”„ Next Steps

1. **Use Prompt #1** with ChatGPT/Claude to identify which fitness functions your project needs
2. **Use Prompt #2** to generate the test code
3. **Review generated code** using the checklist above
4. **Run tests locally**: `npm test tests/fitness-functions`
5. **Create baselines**: Run tests once, copy results to `baseline/`
6. **Integrate CI**: Add workflow to `.github/workflows/`
7. **Start in warning mode**: Monitor for 2 weeks, then switch to blocking
8. **Monitor trends**: Track metrics over time (Grafana, DataDog)
9. **Refactor violations**: Use [Technical Debt Management](technical-debt) to prioritize fixes

---

## ðŸ“– Additional Resources

- **[Dependency Hygiene Prompt Pack](dependency-hygiene)** â€” Enforce 90-day freshness rule
- **[Technical Debt Management](technical-debt)** â€” Track and prioritize refactoring work
- **Book**: *Building Evolutionary Architectures* (Ford, Parsons, Kua)

---

**Remember**: Fitness functions prevent architectural erosion. Manual reviews catch bugs; fitness functions enforce quality standards automatically.
