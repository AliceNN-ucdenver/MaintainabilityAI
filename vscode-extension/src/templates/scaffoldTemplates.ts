import * as fs from 'fs';
import * as path from 'path';
import type { TechStack } from '../types';
import { serializeMetadataYaml, type RepoMetadata } from '../services/RepoMetadata';

// ============================================================================
// HELPERS
// ============================================================================

/** Read a file from the extension's scaffolding directory. */
function readScaffoldFile(extensionPath: string, ...segments: string[]): string {
  const filePath = path.join(extensionPath, 'scaffolding', ...segments);
  return fs.existsSync(filePath) ? fs.readFileSync(filePath, 'utf8') : '';
}

export function generateClaudeMd(stack: TechStack): string {
  return `# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**Tech Stack**: ${stack.language}, ${stack.runtime}, ${stack.framework}
**Database**: ${stack.database}
**Testing**: ${stack.testing}
**Validation**: ${stack.validation}
**CI/CD**: ${stack.cicd}

## Security Framework

This project follows the MaintainabilityAI security-first SDLC framework:
- OWASP Top 10 prompt packs for security guidance
- STRIDE threat modeling for design reviews
- Fitness functions for automated quality gates
- Golden Rules of Vibe Coding for governance

## Development Commands

\`\`\`bash
# Install dependencies
npm install

# Run tests
npm test

# Lint
npm run lint

# Build
npm run build
\`\`\`

## Security Workflow

1. **Be specific** â€” Define intent and security constraints in prompts
2. **Trust but verify** â€” Never merge AI-generated code without understanding it
3. **Treat AI like a junior dev** â€” Review, guide, and validate suggestions
4. **Isolate AI changes** â€” Use separate commits/PRs; label AI-assisted changes
5. **Document rationale** â€” Explain the "why" in code comments and commit messages
6. **Share winning prompts** â€” Capture effective prompts in \`/prompts\` for reuse

## Commit Labeling

Always use the AI disclosure label in commits:
\`\`\`bash
git commit -m "feat: Add user authentication

ðŸ¤– AI-assisted with [tool] using MaintainabilityAI prompt packs"
\`\`\`

---

Generated by MaintainabilityAI VS Code Extension
`;
}

export function generatePrTemplate(): string {
  return `## Summary

<!-- Brief description of changes -->

## Changes

<!-- List of changes made -->

## Security Checklist

- [ ] No new security vulnerabilities introduced
- [ ] Input validation added for all user inputs
- [ ] Error handling does not leak sensitive information
- [ ] Tests cover security-relevant code paths
- [ ] Dependencies are up to date and free of known CVEs

## AI Disclosure

- [ ] This PR includes AI-assisted code
- **Tool(s) used**: <!-- Claude Code / Copilot / ChatGPT -->
- **Prompt pack(s)**: <!-- OWASP A03, Maintainability/complexity-reduction, etc. -->

## Testing

\`\`\`bash
npm test
# All tests passing âœ“
\`\`\`

---

ðŸ¤– Generated with [MaintainabilityAI](https://maintainability.ai)
`;
}

export function generateSecurityPolicy(): string {
  return `# Security Policy

## Reporting a Vulnerability

If you discover a security vulnerability, please report it responsibly:

1. **Do not** create a public GitHub issue
2. Email security concerns to the repository maintainers
3. Include steps to reproduce the vulnerability
4. Allow reasonable time for a fix before public disclosure

## Supported Versions

| Version | Supported |
|---------|-----------|
| Latest  | âœ…        |

## Security Practices

This project follows the MaintainabilityAI security-first framework:
- OWASP Top 10 compliance checks
- Automated security scanning (CodeQL, Snyk)
- Fitness functions for quality gates
- AI-assisted development with human oversight

---

Generated by MaintainabilityAI VS Code Extension
`;
}

export function generateAliceRemediationWorkflow(extensionPath: string): string {
  return readScaffoldFile(extensionPath, 'workflows', 'alice-remediation.yml');
}

export function generateCodeqlWorkflow(extensionPath: string): string {
  return readScaffoldFile(extensionPath, 'workflows', 'codeql.yml');
}

export function generateFitnessFunctionsWorkflow(stack: TechStack, extensionPath: string): string {
  const cmds = getStackCommands(stack);
  let yml = readScaffoldFile(extensionPath, 'workflows', 'fitness-functions.yml');
  yml = yml.replace(/\{\{SETUP_STEPS\}\}/g, cmds.setup);
  yml = yml.replace(/\{\{INSTALL_CMD\}\}/g, cmds.install);
  yml = yml.replace(/\{\{TEST_COVERAGE_CMD\}\}/g, cmds.testCoverage);
  yml = yml.replace(/\{\{TEST_FITNESS_CMD\}\}/g, cmds.testFitness);
  return yml;
}

// ============================================================================
// STACK-AWARE CI WORKFLOW
// ============================================================================

function getStackCommands(stack: TechStack): {
  setup: string;
  install: string;
  test: string;
  testCoverage: string;
  testFitness: string;
  testJson: string;
  envSetup: string;
  lintStep: string;
} {
  const lang = stack.language?.toLowerCase() || '';
  const pm = stack.packageManager?.toLowerCase() || 'npm';
  const testing = stack.testing?.toLowerCase() || '';

  if (lang === 'python') {
    const hasPyproject = stack.runtime?.includes('pyproject');
    const pyManifest = hasPyproject ? 'pyproject.toml' : 'requirements.txt';
    const pyInstall = hasPyproject ? 'pip install -e ".[dev]"' : 'pip install -r requirements.txt';
    return {
      setup: '      - uses: actions/setup-python@v5\n        with:\n          python-version: "3.12"',
      install: `if [ -f ${pyManifest} ]; then ${pyInstall}; fi`,
      test: `if [ -f ${pyManifest} ]; then pytest --tb=short; fi`,
      testCoverage: 'pytest --cov --tb=short',
      testFitness: 'pytest tests/fitness_functions/ --tb=short',
      testJson: `if [ -f ${pyManifest} ]; then pytest --tb=short --junitxml=test-results.xml 2>&1 | tee test-output.txt; fi`,
      envSetup: '',
      lintStep: `      - name: Lint\n        run: if [ -f ${pyManifest} ]; then pip install ruff && ruff check .; fi`,
    };
  }

  if (lang === 'go') {
    return {
      setup: '      - uses: actions/setup-go@v5\n        with:\n          go-version: "1.22"',
      install: 'if [ -f go.mod ]; then go mod download; fi',
      test: 'if [ -f go.mod ]; then go test ./...; fi',
      testCoverage: 'go test ./... -cover',
      testFitness: 'go test ./tests/fitness-functions/...',
      testJson: 'if [ -f go.mod ]; then go test ./... -json 2>&1 | tee test-output.txt; fi',
      envSetup: '',
      lintStep: '',
    };
  }

  if (lang === 'rust') {
    return {
      setup: '      - uses: dtolnay/rust-toolchain@stable',
      install: 'if [ -f Cargo.toml ]; then cargo fetch; fi',
      test: 'if [ -f Cargo.toml ]; then cargo test; fi',
      testCoverage: 'cargo test',
      testFitness: 'cargo test fitness',
      testJson: 'if [ -f Cargo.toml ]; then cargo test -- --format json 2>&1 | tee test-output.txt; fi',
      envSetup: '',
      lintStep: '      - name: Lint\n        id: lint\n        run: if [ -f Cargo.toml ]; then cargo clippy -- -D warnings 2>&1 | tee lint-output.txt; fi\n        continue-on-error: true',
    };
  }

  // Default: Node.js (JavaScript / TypeScript)
  // Use fallback pattern (strict || lenient) so CI works before a lockfile exists
  let setup = '      - uses: actions/setup-node@v4\n        with:\n          node-version: 20';
  let install = 'if [ -f package.json ]; then npm ci || npm install; fi';
  let testCmd = 'if [ -f package.json ]; then npm test; fi';
  let testCov = 'npm test -- --coverage';
  let testFit = 'npm test tests/fitness-functions/';
  let testJson = 'if [ -f package.json ]; then npm test -- --json --outputFile=test-results.json 2>&1 | tee test-output.txt; fi';
  let lintStep = '      - name: Lint\n        id: lint\n        run: if [ -f package.json ]; then npm run lint --if-present 2>&1 | tee lint-output.txt; fi\n        shell: bash\n        continue-on-error: true';

  if (pm === 'pnpm') {
    setup += '\n      - uses: pnpm/action-setup@v4\n        with:\n          version: 9';
    install = 'if [ -f package.json ]; then pnpm install --frozen-lockfile || pnpm install; fi';
    testCmd = 'if [ -f package.json ]; then pnpm test; fi';
    testCov = 'pnpm test -- --coverage';
    testFit = 'pnpm test tests/fitness-functions/';
    testJson = 'if [ -f package.json ]; then pnpm test -- --json --outputFile=test-results.json 2>&1 | tee test-output.txt; fi';
    lintStep = '      - name: Lint\n        id: lint\n        run: if [ -f package.json ]; then pnpm run lint --if-present 2>&1 | tee lint-output.txt; fi\n        shell: bash\n        continue-on-error: true';
  } else if (pm === 'yarn') {
    install = 'if [ -f package.json ]; then yarn install --frozen-lockfile || yarn install; fi';
    testCmd = 'if [ -f package.json ]; then yarn test; fi';
    testCov = 'yarn test --coverage';
    testFit = 'yarn test tests/fitness-functions/';
    testJson = 'if [ -f package.json ]; then yarn test --json --outputFile=test-results.json 2>&1 | tee test-output.txt; fi';
    lintStep = '      - name: Lint\n        id: lint\n        run: if [ -f package.json ]; then yarn run lint --if-present 2>&1 | tee lint-output.txt; fi\n        shell: bash\n        continue-on-error: true';
  } else if (pm === 'bun') {
    setup = '      - uses: oven-sh/setup-bun@v2';
    install = 'if [ -f package.json ]; then bun install; fi';
    testCmd = 'if [ -f package.json ]; then bun test; fi';
    testCov = 'bun test';
    testFit = 'bun test tests/fitness-functions/';
    testJson = 'if [ -f package.json ]; then bun test 2>&1 | tee test-output.txt; fi';
    lintStep = '      - name: Lint\n        id: lint\n        run: if [ -f package.json ]; then bun run lint 2>&1 | tee lint-output.txt; fi\n        shell: bash\n        continue-on-error: true';
  }

  // Vitest uses different flags
  if (testing === 'vitest') {
    const runner = pm === 'pnpm' ? 'pnpm' : pm === 'yarn' ? 'yarn' : pm === 'bun' ? 'bun' : 'npx';
    testJson = `if [ -f package.json ]; then ${runner} vitest run --reporter=json --outputFile=test-results.json 2>&1 | tee test-output.txt; fi`;
    testCov = `${runner} vitest run --coverage`;
  } else if (testing === 'mocha') {
    const runner = pm === 'pnpm' ? 'pnpm exec' : pm === 'yarn' ? 'yarn' : 'npx';
    testJson = `if [ -f package.json ]; then ${runner} mocha --exit --reporter json 2>&1 | tee test-output.txt; fi`;
  }

  return {
    setup,
    install,
    test: testCmd,
    testCoverage: testCov,
    testFitness: testFit,
    testJson,
    envSetup: '      - run: cp .env.example .env 2>/dev/null || true',
    lintStep,
  };
}

export function generateCiWorkflow(stack: TechStack, extensionPath: string): string {
  const cmds = getStackCommands(stack);
  const lang = stack.language?.toLowerCase() || '';

  const failureScriptFile = lang === 'python' ? 'ci-failure-handler-python.js' : 'ci-failure-handler-node.js';
  let yml = readScaffoldFile(extensionPath, 'workflows', 'ci.yml');
  const failureScript = readScaffoldFile(extensionPath, 'scripts', failureScriptFile);
  const closeScript = readScaffoldFile(extensionPath, 'scripts', 'ci-success-closer.js');

  // Replace tokens
  yml = yml.replace(/\{\{SETUP_STEPS\}\}/g, cmds.setup);
  yml = yml.replace(/\{\{INSTALL_CMD\}\}/g, cmds.install);
  yml = yml.replace(/\{\{TEST_CMD\}\}/g, cmds.testJson);
  yml = yml.replace(/\{\{ENV_SETUP\}\}/g, cmds.envSetup || '');
  yml = yml.replace(/\{\{LINT_STEP\}\}/g, cmds.lintStep || '');
  yml = yml.replace(/\{\{FAILURE_SCRIPT\}\}/g, failureScript.split('\n').map((l, i) => i === 0 ? l : '            ' + l).join('\n'));
  yml = yml.replace(/\{\{CLOSE_SCRIPT\}\}/g, closeScript.split('\n').map((l, i) => i === 0 ? l : '            ' + l).join('\n'));

  return yml;
}

export function generateRepoMetadata(stack: TechStack, modelFamily?: string): string {
  const moduleSystem = stack.runtime?.includes('ESM') || stack.runtime?.includes('Vite') ? 'ESM' : 'CommonJS';
  const meta: RepoMetadata = {
    language: stack.language || undefined,
    module_system: stack.language?.toLowerCase() === 'python' ? undefined : moduleSystem,
    testing: stack.testing || undefined,
    package_manager: stack.packageManager || undefined,
    framework: stack.framework || undefined,
    database: stack.database || undefined,
  };
  if (modelFamily) {
    meta.llm = { model_family: modelFamily };
  }
  return serializeMetadataYaml(meta);
}

export function generateCodeqlToIssuesWorkflow(extensionPath: string): string {
  return readScaffoldFile(extensionPath, 'workflows', 'codeql-to-issues.yml');
}

export function generateValidatePromptHashesWorkflow(extensionPath: string): string {
  return readScaffoldFile(extensionPath, 'workflows', 'validate-prompt-hashes.yml');
}

export function generatePromptMappings(extensionPath: string): string {
  return readScaffoldFile(extensionPath, 'scripts', 'prompt-mappings.json');
}

export function generatePromptHashGenerator(extensionPath: string): string {
  return readScaffoldFile(extensionPath, 'scripts', 'generate-prompt-hashes.js');
}

export function generateProcessCodeqlResults(extensionPath: string): string {
  return readScaffoldFile(extensionPath, 'scripts', 'process-codeql-results.js');
}
