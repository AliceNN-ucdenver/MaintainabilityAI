import type { Criticality } from '../../types';

// ============================================================================
// BAR (Business Application Repository) Templates
// ============================================================================

export function generateAppYaml(
  id: string,
  name: string,
  portfolioId: string,
  platformId: string,
  criticality: Criticality,
  repos?: string[]
): string {
  const reposList = repos && repos.length > 0
    ? `repos:\n${repos.map(r => `    - "${r}"`).join('\n')}`
    : 'repos: []';

  return `# Business Application Repository — generated by MaintainabilityAI Looking Glass
application:
  id: ${id}
  name: "${name}"
  portfolio: ${portfolioId}
  platform: ${platformId}
  criticality: ${criticality}
  lifecycle: build
  strategy: reassess          # REAP: reassess | extract | advance | prune
  owner: ""
  description: ""
  ${reposList}
`;
}

// -- Architecture pillar --

export function generateConceptualView(appName: string): string {
  return `# Conceptual Architecture — ${appName}

## Overview

Describe the high-level conceptual architecture of the application.

## Key Components

| Component | Purpose | Technology |
|-----------|---------|------------|
| | | |

## Design Principles

-
`;
}

export function generateLogicalView(appName: string): string {
  return `# Logical Architecture — ${appName}

## Component Diagram

Describe the logical components, their responsibilities, and interactions.

## Layer Structure

| Layer | Components | Responsibility |
|-------|-----------|---------------|
| Presentation | | |
| Business Logic | | |
| Data Access | | |
| Infrastructure | | |
`;
}

export function generateContextView(appName: string): string {
  return `# System Context — ${appName}

## Context Diagram

Describe the system boundaries, external actors, and integrations.

## External Systems

| System | Direction | Protocol | Purpose |
|--------|-----------|----------|---------|
| | | | |

## Actors

| Actor | Role | Access Level |
|-------|------|-------------|
| | | |
`;
}

export function generateSequenceView(appName: string): string {
  return `# Key Sequence Flows — ${appName}

## Primary Flows

### Flow 1: [Name]

Describe the primary interaction sequence.

\`\`\`
Actor -> System: Request
System -> Database: Query
Database -> System: Result
System -> Actor: Response
\`\`\`
`;
}

export function generateTemplateAdr(appName: string): string {
  return `# ADR-001: Initial Architecture for ${appName}

## Status

proposed

## Date

${new Date().toISOString().split('T')[0]}

## Deciders

Architecture Team

## Context

The ${appName} application requires an initial architecture that balances scalability, maintainability, and security requirements. The team needs to establish foundational patterns and technology choices.

## Decision

Adopt a service-oriented architecture with CALM (Common Architecture Language Model) for architecture-as-code, enabling automated governance and compliance tracking.

## Consequences

Positive: Architecture decisions are tracked as code, enabling automated validation. CALM provides machine-readable architecture artifacts that integrate with governance tooling.

Negative: Initial learning curve for CALM JSON format. Requires tooling support for diagram generation.

## Alternatives

1. Traditional documentation-only approach (Confluence/wiki) — rejected due to drift risk
2. C4 model with Structurizr — considered but CALM provides better governance integration
3. ArchiMate — too heavyweight for the current team size

## References

- FINOS CALM specification: https://calm.finos.org
- BTABoK Architecture Decision Record: https://iasa-global.github.io/btabok/architecture_decision_record.html

## Characteristics

reversibility: 2
cost: 3
risk: 3
complexity: 2
effort: 3
`;
}

export function generateSampleClaimsAdr002(): string {
  return `# ADR-002: Adopt Event-Driven Claims Processing Pipeline

## Status

accepted

## Date

${new Date().toISOString().split('T')[0]}

## Deciders

Claims Engineering Lead, Platform Architect

## Context

Claims processing currently uses synchronous REST calls between services, causing tight coupling and cascading failures during peak filing periods. The fraud detection system needs real-time access to claims data without adding latency to the primary submission flow.

## Decision

Implement an event-driven architecture using a message broker for the claims processing pipeline. Claims submission publishes events that are consumed asynchronously by fraud detection, policy validation, and notification services.

## Consequences

Positive: Decoupled services reduce blast radius of failures. Fraud detection can process claims asynchronously without blocking submissions. Natural audit trail via event log. Enables future event sourcing for claims history.

Negative: Increased operational complexity with message broker infrastructure. Eventual consistency requires careful handling of claim status updates. Debugging distributed flows is harder than synchronous calls.

## Alternatives

1. Keep synchronous REST — rejected due to cascading failure risk at scale
2. GraphQL federation — considered but doesn't solve the coupling problem for background processing
3. gRPC with circuit breakers — improves performance but maintains synchronous coupling

## References

- Claims Processing architecture: architecture/bar.arch.json
- ADR-001: Initial Architecture for Claims Processing

## Characteristics

reversibility: 2
cost: 2
risk: 3
complexity: 2
effort: 2

## Links

- depends-on: ADR-001
`;
}

export function generateSamplePolicyAdminAdr002(): string {
  return `# ADR-002: PostgreSQL for Policy Data Store

## Status

accepted

## Date

${new Date().toISOString().split('T')[0]}

## Deciders

Policy Administration Team Lead, DBA

## Context

Policy administration requires a reliable, ACID-compliant data store for policy records, endorsements, and billing information. The data model is highly relational with complex queries for rating, coverage lookups, and regulatory reporting.

## Decision

Use PostgreSQL as the primary data store for policy administration. Leverage JSONB columns for flexible policy document storage alongside relational tables for structured data.

## Consequences

Positive: Strong ACID compliance for financial data integrity. Rich indexing and query capabilities for complex reporting. JSONB provides schema flexibility for varying policy types without schema migrations.

Negative: Single-database dependency requires robust backup/DR strategy. May need read replicas for reporting workloads to avoid impacting transactional performance.

## Alternatives

1. MongoDB — rejected due to ACID requirements for financial data
2. Oracle — considered but licensing cost and operational overhead too high
3. CockroachDB — interesting for distributed use case but adds complexity we don't need yet

## Characteristics

reversibility: 1
cost: 3
risk: 2
complexity: 3
effort: 3

## Links

- depends-on: ADR-001
`;
}

export function generateSampleFraudAdr002(): string {
  return `# ADR-002: ML Model Serving with Feature Store Pattern

## Status

proposed

## Date

${new Date().toISOString().split('T')[0]}

## Deciders

ML Engineering Lead, Fraud Detection Architect

## Context

The fraud detection system needs to serve ML model predictions with low latency (<100ms p95) while maintaining model versioning, A/B testing capability, and a consistent feature computation layer between training and serving.

## Decision

Adopt a feature store pattern that separates feature computation from model serving. Pre-computed features are cached for real-time serving while batch features are computed offline for training consistency.

## Consequences

Positive: Consistent features between training and serving eliminates training-serving skew. Feature reuse across multiple models. Low-latency serving via pre-computed feature cache. Model versioning enables safe rollbacks.

Negative: Additional infrastructure for feature store. Feature computation pipeline adds operational complexity. Cache invalidation strategy needed for real-time features.

## Alternatives

1. Direct feature computation in request path — rejected due to latency requirements
2. All features computed in batch — rejected because some fraud signals require real-time data
3. Third-party ML platform (SageMaker) — considered but vendor lock-in concern for core fraud capability

## Characteristics

reversibility: 3
cost: 2
risk: 4
complexity: 1
effort: 2

## Links

- depends-on: ADR-001
- related: ADR-002
`;
}

// -- IMDB Lite ADRs --

export function generateImdbLiteMongoAdr(): string {
  return `# ADR-002: MongoDB Document Store for Movie Data

## Status

accepted

## Date

${new Date().toISOString().split('T')[0]}

## Deciders

IMDB Lite Engineering Lead, Data Architect

## Context

The IMDB Lite application needs a data store for movies, actors, characters, and user reviews. Movies contain nested cast arrays (actors playing characters), varying metadata fields, and poster image URLs. A relational model would require many join tables (movies, actors, characters, movie_cast, reviews) with complex queries for common operations like "get movie with full cast."

## Decision

Use MongoDB with Mongoose ODM. Movies are stored as self-contained documents with embedded actor/character arrays. Reviews are stored as separate documents referencing movies via ObjectId, enabling independent pagination and moderation. User accounts are a separate collection with bcrypt-hashed credentials.

## Consequences

Positive: Flexible schema accommodates varying movie metadata without migrations. Embedded cast arrays make single-document reads fast for the primary use case (movie detail page). Mongoose provides schema validation at the application layer. Natural fit for a read-heavy, public data workload.

Negative: No multi-document ACID transactions (acceptable for this use case — movie data is not financially sensitive). Must handle eventual consistency for aggregate rating calculations. Denormalized actor data across movie documents requires update fan-out when actor profiles change.

## Alternatives

1. PostgreSQL with JSONB — considered but adds ORM complexity for a document-oriented data model
2. DynamoDB — rejected due to vendor lock-in and complex query patterns for search
3. SQLite — too limited for concurrent access in a multi-user web application

## References

- IMDB Lite architecture: architecture/bar.arch.json
- ADR-001: Initial Architecture for IMDB Lite Application

## Characteristics

reversibility: 2
cost: 4
risk: 3
complexity: 3
effort: 3

## Links

- depends-on: ADR-001
`;
}

export function generateImdbLiteJwtRbacAdr(): string {
  return `# ADR-003: JWT with Inline RBAC for Authentication and Authorization

## Status

accepted

## Date

${new Date().toISOString().split('T')[0]}

## Deciders

IMDB Lite Engineering Lead, Security Architect

## Context

The application needs authentication (who is the user?) and authorization (what can they do?). Three user tiers exist: anonymous viewers who can browse movies, authenticated reviewers who can post reviews, and administrators who manage the movie catalog. Options considered: external identity provider (Auth0/Cognito), session-based authentication with cookies, or JWT with role-based access control.

## Decision

Implement JWT bearer tokens issued by the Movie API. Three roles are defined: \`viewer\` (default anonymous read access), \`reviewer\` (authenticated users who can post reviews and ratings), and \`admin\` (content administrators who can create/edit/delete movies, actors, and characters). Roles are stored as claims in the JWT payload and validated by Express middleware on each request. Passwords are hashed with bcrypt (cost factor 12).

## Consequences

Positive: Stateless authentication eliminates the need for a session store. JWT claims carry role information, enabling middleware-based RBAC without database lookups on every request. Simple implementation appropriate for a lightweight application. Clear separation of concerns between authentication (JWT issuance) and authorization (middleware role checks).

Negative: Token revocation requires short expiration windows plus refresh token rotation. JWT payload size increases slightly with role claims. Would need to migrate to an external identity provider (Auth0, Cognito) if the application scales to production with social login or SSO requirements.

## Alternatives

1. Auth0/Cognito — rejected as over-engineered for a lite application; adds external dependency and cost
2. Session-based with Redis — considered but adds infrastructure (Redis) for session storage
3. OAuth2 + OIDC — full specification is heavyweight for three simple roles

## References

- IMDB Lite architecture: architecture/bar.arch.json
- ADR-001: Initial Architecture for IMDB Lite Application
- ADR-002: MongoDB Document Store for Movie Data

## Characteristics

reversibility: 2
cost: 4
risk: 3
complexity: 3
effort: 3

## Links

- depends-on: ADR-001
- related: ADR-002
`;
}

export function generateFitnessFunctions(): string {
  return `# Architecture Fitness Functions
# Automated quality gates for this application

functions:
  - name: complexity
    description: "Cyclomatic complexity must not exceed threshold"
    threshold: 10
    tool: pmat
    frequency: every_pr

  - name: test_coverage
    description: "Test coverage must meet minimum threshold"
    threshold: 80
    tool: coverage
    frequency: every_pr

  - name: dependency_freshness
    description: "Dependencies must not be older than threshold"
    threshold_days: 90
    tool: pmat
    frequency: weekly
`;
}

export function generateQualityAttributes(): string {
  return `# Quality Attribute Scenarios
# Define measurable quality requirements

scenarios:
  - attribute: Performance
    stimulus: "User submits request"
    response: "System responds within SLA"
    measure: "p95 < 200ms"

  - attribute: Security
    stimulus: "Unauthorized access attempt"
    response: "System denies and logs attempt"
    measure: "0 unauthorized access incidents"

  - attribute: Availability
    stimulus: "Component failure"
    response: "System continues operating"
    measure: "99.9% uptime"
`;
}

// -- Security pillar --

export function generateThreatModel(appName: string): string {
  return `# Threat Model — ${appName}
# STRIDE-based threat analysis

metadata:
  application: "${appName}"
  last_review: ""
  next_review: ""

threats: []
# Example:
#   - id: THR-001
#     category: spoofing
#     description: "Attacker impersonates legitimate user"
#     impact: high
#     likelihood: medium
#     mitigation: "Multi-factor authentication"
#     status: mitigated
`;
}

export function generateSecurityControls(): string {
  return `# Security Controls
# OWASP / NIST control mapping

controls: []
# Example:
#   - id: CTL-001
#     category: authentication
#     owasp: A07
#     description: "bcrypt password hashing with cost factor >= 12"
#     implemented: false
#     evidence: ""
`;
}

export function generateVulnerabilityTracking(): string {
  return `# Vulnerability Tracking
# Known vulnerabilities and remediation status

vulnerabilities: []
# Example:
#   - id: VUL-001
#     source: codeql
#     severity: high
#     description: "SQL injection in user search endpoint"
#     discovered: "2026-01-15"
#     status: remediated
#     remediation: "Parameterized queries implemented"
`;
}

export function generateComplianceChecklist(): string {
  return `# Security Compliance Checklist

checklist:
  authentication:
    - item: "Passwords hashed with bcrypt (cost >= 12)"
      status: not_started
    - item: "Session tokens use secure random generation"
      status: not_started
    - item: "MFA available for privileged accounts"
      status: not_started

  authorization:
    - item: "Deny-by-default access control"
      status: not_started
    - item: "RBAC or ABAC implemented"
      status: not_started

  input_validation:
    - item: "All inputs validated against schemas"
      status: not_started
    - item: "Parameterized queries for database access"
      status: not_started

  logging:
    - item: "Security events logged"
      status: not_started
    - item: "PII masked in logs"
      status: not_started
`;
}

// -- Information Risk pillar --

export function generateIra(appName: string): string {
  return `# Information Risk Assessment — ${appName}

## Application Overview

| Field | Value |
|-------|-------|
| Application | ${appName} |
| Data Owner | |
| Risk Level | |
| Last Assessment | |

## Data Inventory

Describe what data this application processes, stores, and transmits.

## Risk Register

| Risk ID | Description | Impact | Likelihood | Mitigation | Status |
|---------|-------------|--------|------------|------------|--------|
| | | | | | |

## Regulatory Requirements

List applicable regulations (GDPR, HIPAA, SOX, etc.) and compliance status.
`;
}

export function generateDataClassification(): string {
  return `# Data Classification Matrix

data_elements: []
# Example:
#   - element: "User email addresses"
#     classification: confidential
#     retention: "Duration of account + 30 days"
#     encryption_required: true
#     pii: true
`;
}

export function generateVism(): string {
  return `# Vital Information Security Matrix (VISM)

assets: []
# Example:
#   - asset: "Customer database"
#     confidentiality: high
#     integrity: high
#     availability: high
#     classification: restricted
#     owner: ""
`;
}

export function generatePrivacyImpact(): string {
  return `# Privacy Impact Assessment

assessment:
  pii_collected: []
  # Example:
  #   - type: "Email address"
  #     purpose: "Account authentication"
  #     retention: "Account lifetime"
  #     shared_with: []
  #     consent_mechanism: "Registration form"

  data_flows: []
  # Example:
  #   - from: "Web application"
  #     to: "Database"
  #     data: "User PII"
  #     encryption: "TLS 1.3 + AES-256"

  risks: []
`;
}

// -- Operations pillar --

export function generateRunbook(appName: string): string {
  return `# Application Runbook — ${appName}

## Overview

Brief description of the application and its purpose.

## Architecture

Key components and their relationships.

## Deployment

### Prerequisites
-

### Deployment Steps
1.

### Rollback Procedure
1.

## Monitoring

| Metric | Threshold | Alert |
|--------|-----------|-------|
| | | |

## Troubleshooting

### Common Issues

| Symptom | Cause | Resolution |
|---------|-------|------------|
| | | |

## Contacts

| Role | Name | Contact |
|------|------|---------|
| Owner | | |
| On-call | | |
`;
}

export function generateServiceMapping(): string {
  return `# Service Mapping

services: []
# Example:
#   - name: "API Gateway"
#     type: upstream
#     protocol: HTTPS
#     sla: "99.9%"
#     owner: ""

dependencies: []
# Example:
#   - name: "PostgreSQL"
#     type: infrastructure
#     version: "16"
#     managed_by: "Platform team"
`;
}

export function generateSlaDefinitions(): string {
  return `# SLA Definitions

sla:
  availability:
    target: "99.9%"
    measurement: monthly
    exclusions:
      - "Planned maintenance windows"

  performance:
    response_time_p50: "50ms"
    response_time_p95: "200ms"
    response_time_p99: "500ms"

  recovery:
    rto: "4h"
    rpo: "1h"

  support:
    severity_1: "1h response"
    severity_2: "4h response"
    severity_3: "1 business day"
`;
}

export function generateIncidentResponse(): string {
  return `# Incident Response Procedures

escalation:
  levels:
    - level: 1
      description: "On-call engineer"
      response_time: "15 minutes"
    - level: 2
      description: "Team lead"
      response_time: "30 minutes"
    - level: 3
      description: "Engineering manager"
      response_time: "1 hour"

communication:
  channels:
    - type: "Slack"
      channel: ""
    - type: "PagerDuty"
      service: ""

  templates:
    initial: "Incident detected: [description]. Investigating. ETA: [time]."
    update: "Update on [incident]: [status]. Next update in [time]."
    resolved: "Incident [id] resolved. Duration: [time]. RCA to follow."

rollback:
  steps:
    - "Identify the failing deployment"
    - "Revert to last known good version"
    - "Verify health checks pass"
    - "Monitor for 15 minutes"
    - "Notify stakeholders"
`;
}

// -- Governance --

export function generateBarDecisionsYaml(): string {
  return `# Application Governance Decisions
decisions: []
# Example:
#   - id: DEC-001
#     title: "Adopt PostgreSQL for primary datastore"
#     status: approved
#     date: "2026-02-17"
#     owner: ""
`;
}
